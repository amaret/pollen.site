<!DOCTYPE html>
<html lang="en">

  <head>
    
    <!-- Meta, title, CSS, favicons, etc. -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Pollen, a new programming language for tiny computers by Amaret, Inc.">
    <meta name="keywords" content="programming, programming languages, languages, hardware, microcontroller, embedded system, embedded systems, embedded systems programming, embedded development, microcontroller software, microcontroller software development">
    <meta name="author" content="Amaret, Inc.">

    <title>Programming Pollen</title>

    <!-- Bootstrap core CSS -->
    <link href="../../static/css/bootstrap.css" rel="stylesheet" />

    <!-- Prism CSS -->
    <link href="../../static/css/prism.css" rel="stylesheet" />

    <!-- Amaret core CSS -->
    <link href="../../static/css/pollen.css" rel="stylesheet" />

    <!-- Favicons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="static/ico/apple-touch-icon-144-precomposed.png">
    <link rel="icon" href="static/ico/favicon.ico">

    <!-- analytics --> 
    <script></script>
  </head>

  <body class="doc-page language-javascript" data-spy="scroll" data-target="#doc-sidenav">

    <div class="navbar navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="http://localhost/~amichi/pollen/index.html">Pollen</a>
    </div>
    <div class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li id="introduction"><a href="http://localhost/~amichi/pollen/introduction/index.html">Introduction</a></li>
        <li><a href="http://localhost/~amichi/pollen/guide/index.html">Language Guide</a></li>
        <li><a href="http://localhost/~amichi/pollen/reference/index.html">Reference</a></li>
        <li><a href="http://localhost/~amichi/pollen/compiler/index.html">Compiler</a></li>
        <li><a href="">Support</a></li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li><a href="">About</a></li>
      </ul>
    </div>
  </div>
</div>


    <div class="doc-header">
      <div class="container">
        <h1>Programming Pollen</h1>
        <p>A practical guide to the Pollen language features and how to make use of them effectively.</p>
      </div>
    </div>

    <div class="container doc-container" style="padding-bottom: 60px">
      <div class="row" id="content">
        <div class="col-md-3">
  <nav id="doc-sidenav" class="doc-sidebar hidden-print hidden-xs hidden-sm" role="navigation">
    <h4>Language Guide</h4>
<ul class="nav doc-sidenav affix-top" data-spy="affix" data-offset-top="10" data-offset-bottom="200" style="margin-top: 0px">
  <li><a href="http://localhost/~amichi/pollen/guide">The Basics</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/operators">Basic Operators</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/strings">Strings and Characters</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/arrays">Arrays</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/control-flow">Control Flow</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/function-references">Function References</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/host-initialization">Host Initialization</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/modules">Modules</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/protocols">Protocols</a></li>  
  <li><a href="http://localhost/~amichi/pollen/guide/compositions">Compositions</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/classes">Classes</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/enumerations">Enumerations</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/meta">Meta Types</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/print-keyword">Print Keyword</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/intrinsics">Intrinsics</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/c-code">C Code Injection</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/packages-bundles">Packages &amp; Bundles</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/pollen-corelib">Core Library</a>
    <ul>
        <li><a href="http://localhost/~amichi/pollen/guide/pollen-events">Events</a></li>
        <li><a href="http://localhost/~amichi/pollen/guide/pollen-timers">Timers</a></li>
    </ul>
  </li>
  
</ul>

  </nav>
</div>

<div class="col-md-9" role="main">

  <h1 id="control-flow" class="page-header" style="margin-top: 5px">Compositions</h1>

<p class="lead"> 
A composition is a configuration module. 
</p>

<p>A composition is used to assemble and configure
a set of modules that implement a subsystem. It imports modules and creates an interface of available functionality through its exports. </p>

<pre><code>     import Cpu
     import GlobalInterrupts
     import PinMeta{"B", 0} as PB0
     import TimerMilliTC1
     import Uart0 as Uart

     composition MyBoard {
        
         host MyBoard() { ... }

         export Cpu
         export GlobalInterrupts
         export TimerMilliTC1
         export Uart
         export PB0
     }
</code></pre>

<p>For a target platform a composition could include configuration for interrupts,
uart, GPIO, and lifecycle functions specific to that platform. An application
running on that platform will import the composition to do the configuration.
This has the effect of separating the configuration from the  application code,
making it easier to retarget the application. </p>

<p>The cloud bundles have a bundle for atmel which you can inspect. Compositions for ATmega168,
ATmega328, and ATmega88 can be found there. </p>

<p>Compositions are a type of module that is host phase only. They can declare host
functions and host constructors but they cannot declare target functions. They have no code that executes in the target application. Compositions assemble, configure, and initialize sets of modules so their purpose is host phase only.</p>

<h4 class="page-header" id="ref-compos-flex-interf">
Use Case: Building A Flexible Single Interface From Multiple Modules
</h4>

<p>In the module section we showed <code>I2C</code>, a module which implements a
standard integrated circuit bus; this module imports the composition for the
Atmega328p. That composition assembles and configures all the constituents of
the ATmega328p hardware target. However the <code>I2C</code> doesn’t need all of that. 
It only needs the <code>TwoWireInterrupt</code>. This import statement shows how to import
only what is needed from a composition: </p>

<pre><code>from ATmega328 import TwoWireInterrupt as TWInterrupt
</code></pre>

<p>This selective import is available for <code>ATmega328</code> because that composition
contains this export statement:</p>

<pre><code>export TwoWireInterrupt
</code></pre>

<p>Compositions support building flexible interfaces from a set of
independent modules. The composition interface is defined by its set of exports. 
The application need import only what it needs from that set.
The module that implements the functionlity (here <code>TwoWireInterrupt</code>) 
is encapsulated and independent of its
client.  This makes portability for multiple hardware targets
easier. Compositions can be used to flexibly combine or subset the functionality of a set
of modules as required by the application and the target hardware.</p>

<h4 class="page-header" id="ref-compos-init">
Use Case: Initialization And Configuration Of A Module Outside The Module
</h4>

<p>In the protocol section we showed the use of a hardware timer configured for the Arduino. 
The timer was initialized (in the composition <code>Uno</code>) in this statement:</p>

<pre><code>   TimerManager.HwTimer := TimerMilliTC1                   // hardware timer initialization
</code></pre>

<p><code>TimerManager.HwTimer</code> is being configured and initialized outside of its
module <code>TimerManager</code>. This enables the <code>TimerManager</code> module to be adapted to requirements of multiple hardware 
targets without changing any <code>TimerManager</code> code. The ability to initialize and configure modules from outside 
supports code reuse and portability. </p>

<p>Compositions use imports to construct the composition functionality, exports to define the public interface, and host code (any combination of the preset initializer, host constructor, and host functions) to initialize constituent modules.
Below is the <code>Uno</code> composition showing these elements in a real life example.</p>

<pre><code>!--
  Composition that defines an environment for the Arduino Uno
 --!

from atmel.atmega import ATmega328 as Mcu
from Mcu import GlobalInterrupts
from Mcu import TimerMilliTC1
from Mcu import Timer1MatchAInterrupt
from Mcu import PB5
from Mcu import PB4
from Mcu import PB3

from pollen.event import Newsroom
from pollen.time import TimerManager
from pollen.parts import LedMeta as Led

composition Uno {

  preset Uno() {
    Led.pin := PB5
    Newsroom.GI := GlobalInterrupts
    TimerMilliTC1.TimerInterrupt := Timer1MatchAInterrupt
    TimerManager.HwTimer := TimerMilliTC1
    Mcu.setFrequencyOnHost(16000000)
    Uart.setBaudOnHost(38400)
  }

  export Mcu
  export GlobalInterrupts
  export Led
  export PB4
  export PB3

}
</code></pre>

<p>Note that this composition imports the <code>ATmega328</code> composition, but selects just what it needs: a timer, a timer interrupt, and 3 gpio pins (<code>PB3</code>, <code>PB4</code>, <code>PB5</code>). It also imports the event and timer abstractions and an Led. The <code>ATmega328</code> modules that are not imported are not included in the application. There is no code bloat from unused code.</p>

<p>&lt;h2 class=”page-header”
The Preset Initializer
&lt;/h2&gt;</p>

<p>The composition <code>Uno</code> defines one method: a <code>preset</code> initializer. This is a special initialization method that can only be defined in compositions.  The <code>preset</code> initializer supports configuration and initialization.
More information can be found 
<a href="http://localhost/~amichi/pollen/guide/host-initialization#ref-preset">here</a>.</p>

<h2 class="page-header" id="ref-export-types">
The Export Statement : Types
</h2>

<p>The export statement is only available in compositions. 
The list of exported types is the interface that is available to clients that
import the composition. </p>

<p>This is the list of exports in the <code>Uno</code> composition:</p>

<pre><code>export Mcu
export GlobalInterrupts
export Led
export PB4
export PB3
</code></pre>

<p>If <code>MyApp</code> imports <code>Uno</code> this way: </p>

<pre><code>import Uno
from Uno import PB4 as MyPin        # PB4 as MyPin
</code></pre>

<p>Then the function <code>toggle()</code> of the <code>PB4</code> module could be invoked via <code>MyPin</code>: </p>

<pre><code> MyPin.toggle()                     # call into PB4 via MyPin
</code></pre>

<p>The other exported types of <code>Uno</code> are also available because of the <code>import Uno</code>
statement. However they do not have local names.<br />
Calling the function <code>Led.on()</code> can be done using full qualification:</p>

<pre><code> import Uno
 ...
 Uno.Led.on()                       # a call into Led with full qualification
 ...
</code></pre>

<h2 class="page-header" id="ref-export-fun">
The Export Statement : Functions
</h2>

<p>The export statement can be used to export specific functions from compositions. </p>

<p>If a module <code>Core</code> implements a set of functions which includes <code>wait()</code> and <code>cycle()</code> and the composition <code>ATmega328</code> imports <code>Core</code>, then these functions can be exported. Here is how that export of functions would look:</p>

<pre><code>import Core
   ... 
composition ATmega328 {
   ...
   export Core.wait                # an exported function
   export Core.cycle
   ...
}
</code></pre>

<p>Any importer of ATmega328 can then invoke these functions through the name ATmega328:</p>

<pre><code>import ATmega328 as MyArduino
   ... 
module MyApp {
   ... 
   myFun() { 
     MyArduino.wait()             # calling an exported function via a local name
     MyArduino.cycle()
   }
   ... 
}
</code></pre>

<p>Exporting individual functions by name can be expressive and useful when the
exported function can be thought of as operating on the composition (or
application) as a whole.
The function <code>wait()</code> can be thought of as implementing
functionality for the application on specific hardware.</p>
  
  
</div>


      </div>
    </div>

        <footer class="" role="contentinfo">
      <div class="container section">

          <div class="container">
            <a data-scroll href="http://amaret.com"><img class="brand-logo" src="../../static/img/logo_white_medium.png" /></a>
            <h3 style="margin-top: 0">Integrated Solutions for Product Creation</h3>
            <p>
              Copyright &copy; 2015 Amaret Inc. All rights reserved. <!-- <a href="">Terms of Use</a> &nbsp;|&nbsp;  <a href="">Privacy Policy</a> -->
            </p>
          </div>

      </div>
    </footer>

    <script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
    <script src="../../static/js/pollen.js"></script>
    <script src="../../static/js/prism.js"></script>


  </body>

</html>
