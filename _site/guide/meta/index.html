<!DOCTYPE html>
<html lang="en">

  <head>
    
    <!-- Meta, title, CSS, favicons, etc. -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Pollen, a new programming language for tiny computers by Amaret, Inc.">
    <meta name="keywords" content="programming, programming languages, languages, hardware, microcontroller, embedded system, embedded systems, embedded systems programming, embedded development, microcontroller software, microcontroller software development">
    <meta name="author" content="Amaret, Inc.">

    <title>Programming Pollen</title>

    <!-- Bootstrap core CSS -->
    <link href="../../static/css/bootstrap.css" rel="stylesheet" />

    <!-- Prism CSS -->
    <link href="../../static/css/prism.css" rel="stylesheet" />

    <!-- Amaret core CSS -->
    <link href="../../static/css/pollen.css" rel="stylesheet" />

    <!-- Favicons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="static/ico/apple-touch-icon-144-precomposed.png">
    <link rel="icon" href="static/ico/favicon.ico">

    <!-- analytics --> 
    <script></script>
  </head>

  <body class="doc-page language-javascript" data-spy="scroll" data-target="#doc-sidenav">

    <div class="navbar navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="http://localhost/~amichi/pollen/index.html">Pollen</a>
    </div>
    <div class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li id="introduction"><a href="http://localhost/~amichi/pollen/introduction/index.html">Introduction</a></li>
        <li><a href="http://localhost/~amichi/pollen/guide/index.html">Language Guide</a></li>
        <li><a href="http://localhost/~amichi/pollen/reference/index.html">Reference</a></li>
        <li><a href="http://localhost/~amichi/pollen/compiler/index.html">Compiler</a></li>
        <li><a href="">Support</a></li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li><a href="">About</a></li>
      </ul>
    </div>
  </div>
</div>


    <div class="doc-header">
      <div class="container">
        <h1>Programming Pollen</h1>
        <p>A practical guide to the Pollen language features and how to make use of them effectively.</p>
      </div>
    </div>

    <div class="container doc-container" style="padding-bottom: 60px">
      <div class="row" id="content">
        <div class="col-md-3">
  <nav id="doc-sidenav" class="doc-sidebar hidden-print hidden-xs hidden-sm" role="navigation">
    <h4>Language Guide</h4>
<ul class="nav doc-sidenav affix-top" data-spy="affix" data-offset-top="10" data-offset-bottom="200" style="margin-top: 0px">
  <li><a href="http://localhost/~amichi/pollen/guide">The Basics</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/operators">Basic Operators</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/strings">Strings and Characters</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/arrays">Arrays</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/control-flow">Control Flow</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/function-references">Function References</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/host-initialization">Host Initialization</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/modules">Modules</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/protocols">Protocols</a></li>  
  <li><a href="http://localhost/~amichi/pollen/guide/compositions">Compositions</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/classes">Classes</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/enumerations">Enumerations</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/meta">Meta Types</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/print-keyword">Print Keyword</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/intrinsics">Intrinsics</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/c-code">C Code Injection</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/packages-bundles">Packages &amp; Bundles</a></li>
  <li><a href="http://localhost/~amichi/pollen/guide/pollen-corelib">Core Library</a>
    <ul>
        <li><a href="http://localhost/~amichi/pollen/guide/pollen-events">Events</a></li>
        <li><a href="http://localhost/~amichi/pollen/guide/pollen-timers">Timers</a></li>
    </ul>
  </li>
  
</ul>

  </nav>
</div>

<div class="col-md-9" role="main">

  <h1 id="meta" class="page-header">Meta Types</h1>

<p class="lead"> A meta type is instantiated with <em>value</em> or <em>type</em> parameters, making a new type.  </p>

<p>Embedded applications often have a high degree of similarity in their code functionality, to do the basic work of controlling the hardware, within a context of high variability and complexity in initial configuration of that hardware. Pollen has powerful features that support reuse of code within the context of variable and complex initial configuration.</p>

<p>One powerful feature that supports code reuse in Pollen is meta types. A meta type is instantiated with <em>value</em> or <em>type</em> parameters, making a new type. This is useful for configuration and initialization of gpio pins, leds, and the like. It greatly reduces the amount of code that is required and at the same time enables extensive reuse of that code. </p>

<p>The meta keyword can be used with modules, protocols, compositions, and classes. When the meta keyword is present, the type is a meta type. Whenever meta types are imported, meta parameters must be supplied, and a new type, using those parameters, will be created.</p>

<h2 class="page-header" id="ref-meta-valueparm">
Meta Types with Value Parameters.
</h2>

<p>Here is the definition of <code>LedMeta</code>, a meta type in the <code>pollen-core</code> cloud bundle which takes a
meta value parameter:</p>

<pre><code>meta {bool activeLow}         // activeLow is a meta value parameter
module LedMeta {              // LedMeta is a meta type
    ....
}
</code></pre>

<p>When <code>LedMeta</code> is imported into a unit, a value for the parameter must be available. Such an import is called a meta instantiation:</p>

<pre><code>import LedMeta{true} as Led   // a meta instantiation. 
</code></pre>

<p>Due to the <code>as</code> clause the instantiated type will be referred to in the local context as <code>Led</code>. </p>

<p>An LED can be wired up to light in two ways. If active high the LED is on when signal is high and if active low the LED is on when the signal is low. The new type generated from <code>import LedMeta{true}</code> with all of its code is ready to use with the proper configuration in place.  Any declaration in the importing context that uses <code>Led</code> is using a type which has already been configured with the <code>activeLow</code> parameter. </p>

<p>An instantiation of LedMeta{true} is a different type than an instantiation of LedMeta{false}. There is no type relationship between them. </p>

<p>Meta value types are especially useful for GPIO pins because the number of pins
that need to be configured can be significant so the code reuse enabled by meta
types is also significant. Composition <code>Uno</code> imports and extends composition
<code>ATmega328</code> and in particular imports some of the gpio pins that <code>ATmega328</code>
configures.  Below we show a few of the meta type import statements inside <code>ATmega328</code> for gpio pins. Each import instantiates a type which is given a local name inside <code>ATmega328</code> via the <code>as</code> clause. </p>

<pre><code>!-- General Purpose I/O Pins --!
import PinMeta{"B", 0} as PB0       // type PB0 for pin 0 on port B 
  ...                               // imports omitted for brevity
import PinMeta{"D", 7} as PD7
</code></pre>

<p>The code below shows the <code>PinMeta</code> implementation that is imported above. The meta parameters are <code>port</code> and <code>pin</code>. As this code is used to create modules that will control the pins it has specific hardware dependencies. Thus it includes <code>&lt;avr/io.h&gt;</code> and there is injected C code in most functions. </p>

<pre><code>package atmel.atmega

!--
  Implementation of a meta module for pin drivers
 --!

from pollen.hardware import PinProtocol

meta {string port, uint8 pin}                       // meta parameters port and pin
module PinMeta implements PinProtocol {

  +{ #include &lt;avr/io.h&gt; }+

  host uint8 pinMask

  host PinMeta() {
    pinMask = (1 &lt;&lt; pin)
  }

  // code for toggle(), set(), clear(), get(), isInput() omitted.

}
</code></pre>

<h2 class="page-header" id="ref-meta-pollen-names-injected">
Using Pollen names in Injected Code
</h2>

<p>Here is <code>toggle()</code> in <code>PinMeta</code>:</p>

<pre><code>public toggle() {
    +{ PORT`port` ^= `pinMask` }+
  }
</code></pre>

<p>This function consists of one line of injected C code in which names from the Pollen namespace are used: local variable <code>pinMask</code> and meta parameter <code>port</code>. The use of backticks signifies that a name from the Pollen namespace is being used in injected C code. After the following instantiation that specifies port ‘B’ and pin 5:</p>

<pre><code> import PinMeta{"B", 5} as PB5 
</code></pre>

<p>Then function <code>toggle()</code> would be instantiated as:</p>

<pre><code>public toggle() {
     PORTB ^= pinMask
}
</code></pre>

<p>Note how the Pollen handles substitution with backticks - in particular, note
that the <em>value</em> of the meta parameter is substituted into the code whereas the
<em>name</em> of the Pollen local variable is substituted. </p>

<h2 class="page-header" id="ref-meta-default-parms">
Default Values for Meta Parameters
</h2>

<p>Meta parameters can have default values which are used if no parameters are
supplied. The <code>LedMeta</code> module in the bundle <code>pollen-core</code> is an example. Meta parameter <code>activeLow</code> has a default value of false:</p>

<pre><code>from pollen.hardware import PinProtocol

meta {bool activeLow = false}

module LedMeta {

  PinProtocol pin        // protocol member for the pin.

  ... // code omitted

}
</code></pre>

<p>When the meta parameter has a default value supplying a meta parameter is optional. The above meta type <code>LedMeta</code> can be imported like this:</p>

<pre><code>import LedMeta
</code></pre>

<p>and it will be instantiated with the default value and the local name is <code>LedMeta</code>. </p>

<h2 class="page-header" id="ref-meta-provided">
The Provided Statement for Meta Types
</h2>

<p>The provided statement is a translation time switch that controls what code will
be generated based on the value of a meta parameter. 
The function <code>isOn()</code> in <code>LedMeta</code> uses the provided statement:</p>

<pre><code>  public bool isOn() {
    provided(activeLow == true) { 
      return pin.get() == false
    } else {
      return pin.get() == true
    }
  }
</code></pre>

<p>If <code>activeLow</code> is true the function returns <code>pin.get() == false</code> and vice versa. In the default case (when <code>activeLow</code> is false) the function would be generated as:</p>

<pre><code>  public bool isOn() {
    return (pin.get() == true)
  }
</code></pre>

<h2 class="page-header" id="ref-meta-typeparm"> 
Meta Types with Type Parameters
</h2>

<p>Instantiating meta types with type parameters is useful for types which support
software abstractions such as Queues, Lists, and the like. The type of the Queue
element can be specifed with a meta type parameter. Meta type parameters are
indicated with the keyword <code>type</code>:</p>

<pre><code>meta {type E, type T = uint8}

class Queue {
     ...       
}
</code></pre>

<p>The <code>Queue</code> type is in the <code>pollen-core</code> cloud bundle. Below we show the code with function bodies empty for brevity. (This code can be downloaded.) The host constructor is shown to illustrate how the size of the array can be increased from the default at host time and the array will have constant size and be allocated statically at load time. </p>

<p>Note that in the code of the meta type the name of the type parameter can be used as a type. For example, <code>length</code> has type <code>T</code> and elements has type <code>E</code>. When the types are instantiated these type names will be replaced with the type parameter names. The types used to instantiate meta types can be primitive types or classes (but not modules or protocols).</p>

<pre><code>!--
  First-in-first-out (FIFO) data structure implemented as an array of fixed length.
--!

meta {type E, type T = uint8}

class Queue {

  const uint8 capacity = 10
  host E elements [capacity]
  T length
  T head
  T tail
  T maxLength

  public host Queue(T max) {
    @length = 0
    @head = 0
    @tail = 0
    @maxLength = max

    if (max &gt; @capacity) {
      @capacity = max
    }
  }

  // Default target constructor
  Queue() {}
  public host setCapacity(T capacity) { ... } 
  public bool add(E e) { ... }
  public E remove() { ...  }
}
</code></pre>

<p>The <code>Dispatcher</code> code below shows how this <code>Queue</code> could be used. In this use case, the <code>Queue</code> is being instantiated with <code>Event</code>. If the <code>Queue</code> is empty the <code>Dispatcher</code> will run indefinitely, until an event arrives. </p>

<pre><code>!---
Event Dispatcher
---!

import Event {uint8} as Ev
import Queue {Ev, uint8} as EvQueue    // the Queue will be instantiated with type Ev and type uint8

module Dispatcher {

    host new EvQueue myEventQueue(10)
    host public Dispatcher() {
    }

    public post(Ev e) {
        myEventQueue.add(e)
    }

    public run() {

        while(true) {
            Ev e = myEventQueue.remove()   // remove an event from the queue
            if (e != null) {
                e.handle(e.getData())      // handle event
                break;
            }
        }
    }
}
</code></pre>

<h2 class="page-header" id="ref-meta-import">
The Import Statement for Meta Type Instantiation
</h2>

<p>A meta type instantiation creates a new type. The parameters that instantiate the meta type are passed on the import statement. </p>

<p>Here is <code>LedMeta</code>, a meta type in the <code>pollen-core</code> cloud bundle:</p>

<pre><code>meta {bool activeLow}         // activeLow is a meta parameter

module LedMeta {              // LedMeta is a meta type
    ....
}
</code></pre>

<p>When <code>LedMeta</code> is imported into a unit, a value for the parameter must be available. Such an import is called a meta instantiation:</p>

<pre><code>import LedMeta{true} as Led   // a meta instantiation.
</code></pre>

  
  
</div>


      </div>
    </div>

        <footer class="" role="contentinfo">
      <div class="container section">

          <div class="container">
            <a data-scroll href="http://amaret.com"><img class="brand-logo" src="../../static/img/logo_white_medium.png" /></a>
            <h3 style="margin-top: 0">Integrated Solutions for Product Creation</h3>
            <p>
              Copyright &copy; 2015 Amaret Inc. All rights reserved. <!-- <a href="">Terms of Use</a> &nbsp;|&nbsp;  <a href="">Privacy Policy</a> -->
            </p>
          </div>

      </div>
    </footer>

    <script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
    <script src="../../static/js/pollen.js"></script>
    <script src="../../static/js/prism.js"></script>


  </body>

</html>
